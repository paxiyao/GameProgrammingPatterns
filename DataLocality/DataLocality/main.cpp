/************************************************************************/
/* 
数据局部性：
	当代CPU带有多级缓存以提高内存访问速度。这一机制加快了对最近方位过的数据
	的邻近内存的访问速度。通过增加数据局部性并利用这一点可以提高性能---保持数据位于连续内存中以供程序进行处理
*/
/************************************************************************/

/************************************************************************/
/* 
使用情境：
	如同多数优化措施，指导我们使用数据局部性的模式的第一条准则就是找到出现性能问题的地方。
	不要在那些代码库里非频繁执行的部分浪费时间，他们不需要本模式。对那些非必要的代码进行优化将使你的人数变得艰难.
*/
/************************************************************************/

/************************************************************************/
/* 
CPU缓存技术：
	当代计算机在其芯片内部的内存十分有限。CPU从芯片中读取数据的
	速度要快于它从驻村中读取数据的速度。芯片内存很小，以便嵌入在芯片上，而且由于它
	使用了更快的内存类型，所以更加昂贵。这一小块内存被称为缓存，任何时候当芯片需要RAM中的数据时，它会自动将一整块连续的内存取出来并
	置入缓存中，这块内存被称为缓存线。
*/
/************************************************************************/

/************************************************************************/
/* 
缓存命中：
	如果需要的下一个数据正好的缓存线中，那么CPU直接在缓存中读取数据，要比命中RAM快多了。 
*/
/************************************************************************/

/************************************************************************/
/*   
总结: 
	不论芯片何时读取多少内存，它都整块的获取缓存线。你能够在缓存线中使用数据越多，程序就跑得越快。  
    所以优化的目标就是将你的数据进行组织，以使需要处理的数据对象在内存中两两相邻
*/
/************************************************************************/

#define MAX_ENTITIES 20

class AIComponent
{
public:
	void update() {}
};

class PhysicsComponent
{
public:
	void update() {}
};

class RenderComponent
{
public:
	void update() {}
};

int main()
{
	AIComponent* aiComponents = new AIComponent[MAX_ENTITIES];
	PhysicsComponent* physicsComponent = new PhysicsComponent[MAX_ENTITIES];
	RenderComponent* renderComponent = new RenderComponent[MAX_ENTITIES];

	while (true)
	{
		for (unsigned int i = 0; i < MAX_ENTITIES; i++)
		{
			aiComponents[i].update();
		}
		for (unsigned int i = 0; i < MAX_ENTITIES; i++)
		{
			physicsComponent[i].update();
		}
		for (unsigned int i = 0; i < MAX_ENTITIES; i++)
		{
			physicsComponent[i].update();
		}
	}
	return 0;
}