// 事件(消息)队列:队列按先入先出的顺序存储一系列通知或请求。发送通知将请求排队并返回。然后，请求处理器在稍后的时间处理队列中的项。
//				  请求可以直接处理或路由到相关方。这将静态地和tim中的发送方与接收方解耦

// 使用时机:
// 如果您只想将接收消息的人与消息的发送者解耦，那么像Observer和Command这样的模式将以更少的复杂性处理这个问题。只有当您想及时解耦某些东西时，才需要队列。
// 我几乎在每一章都提到了这一点，但值得强调。复杂性会让你慢下来，所以把简单当作一种宝贵的资源。
// 我认为这是推和拉的关系。有一些代码A想让另一个块B做一些工作。A发起请求的自然方式是将请求推给B。
// 与此同时，B处理该请求的自然方法是在其运行周期的方便时间将其拉入。当一端有一个push模型，另一端有一个pull模型时，它们之间需要一个缓冲区。这就是队列所提供的，而简单的解耦模式所不能提供的。
// 队列将控制权交给从中提取的代码――接收方可以延迟处理、聚合请求或完全丢弃它们。但是队列通过从发送方那里夺走控制权来实现这一点。发送方所能做的就是向队列中抛出一个请求，并希望得到最好的结果。这使得队列在发送方需要响应时不太合适。

// 使用一个首尾相连的数组来实现:循环缓冲
// 没有动态分配。
// 没有内存开销的簿记信息或指针。
// 缓存友好的连续内存使用

// 跨线程
// 最后，最有害的问题。使用同步音频API，任何名为playSound()的线程都是处理请求的线程。这通常不是我们想要的。
// 在今天的多核硬件上，如果你想充分利用芯片，你需要不止一个线程。有无数种方法可以在线程之间分发代码，但一个常见的策略是将游戏的每个域移动到自己的线程上――音频、渲染、AI等等。
// 直线代码一次只能在一个核心上运行。如果不使用线程，即使使用当前流行的异步风格的编程，最好的方法也是让一个核心保持忙碌，这只是CPU能力的一小部分。
// 服务器程序员通过将他们的应用程序分割成多个独立的进程来弥补这一点。这使得操作系统可以在不同的内核上并发地运行它们。游戏几乎总是一个单一的进程，所以线程化是很有帮助的。
// 现在我们已经有了三个关键部分:
// 请求声音的代码与播放声音的代码是解耦的。
// 我们有一个队列用于在两者之间进行编组。
// 队列是从程序的其余部分封装而来的。
// 剩下的工作就是使修改队列 - playSound()和update()的方法线程安全。通常，我会编写一些具体的代码来实现这一点，但是由于这是一本关于体系结构的书，所以我不想陷入任何特定API或锁定机制的细节中。
// 在高层，我们需要做的就是确保队列不会并发地修改。由于playSound()只做很少的工作――基本上只分配几个字段――它可以锁定而不会阻塞处理很长时间。
// 在update()中，我们等待一个类似于条件变量的东西，这样我们就不会消耗CPU周期，直到有一个请求需要处理。

#include "audio.h"

int main()
{
	Audio::init();
	Audio::playSound(1, 1);

	return 0;
}