// 单例模式:延迟初始化和进程运行前(main函数执行前)初始化

// 1.在第一次使用的时候进行初始化,
// 优点:  1.在第一次使用的时候进行初始化, 不提前占用内存
//		  2.支持多态.例如：文件的读写在pc端和移动端是不一样的,可以利用多态去分部实现不同端的文件操作
// 缺点:  1.需要动态分配内存,在游戏动作密集的部分,容易使游戏掉帧卡顿
//        2.在需要的时候再进行初始化,不知道内存分配的时机,不能控制好内存的布局,容易产生内存碎片

// 2.进程运行前(main函数执行前)初始化
// 优点:  1.不需要动态分配内存,提前创建和加载,使游戏运行流畅不会掉帧
//		  2.可以避免内存碎片(游戏通常需要严格控制内存在堆中的布局)
// 缺点:  1.进程运行前(main函数执行前)初始化, 不管使用与否都占用内存
//		  2.不支持带纯虚函数的多态.

// 单例模式总的缺点:
//	1.代码可读性差,
//	2.代码耦合度高,不利于分模块开发
//	3.线程不安全,回出现死锁,资源争夺的情况

// 单例模式的替代方案:
//	1.以传参的方式访问
//	2.将实例放在父类中,所有子类都能访问
//	3.将实例放在已有的全局对象(单例)中
//	4.构造一个全局的服务类专门用来存在其他单例


int main()
{
	return 0;
}